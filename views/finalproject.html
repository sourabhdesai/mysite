<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure.css">
<style>

.node {
  cursor: pointer;
}

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}


</style>

<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="My Final Project Submission for CS 398 VL">

    <title>Final Project</title>

    






<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure.css">



  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/gallery-grid-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/gallery-grid.css">
    <!--<![endif]-->
  

  
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="css/layouts/gallery-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/gallery.css">
    <!--<![endif]-->
  




    

    

    

</head>
<div class="pure-u-1">
    <div class="l-box">
      <h2  style="padding: 0 10px" >Final Project : WikiTree</h2>

      <p style="padding: 0 15px" >
        Over the course of this semester, I've been slowly reading through the book "Zen & the Art of Motorcycle Maintenance" by Robert Pirsig.
        The book covers the journey of a Pirsig with his son as they go on their quest through raw american countryland. Along the journey, Pirsig details many of his deep, complex, philosphical thoughts on topics ranging from technology, reasoning, quality, and education in snippets which he calls Chautauquas. These snippets are mixed in with a storyline that involves Pirsig's relationship with his son, his two best friends, technology, society, and his own past.
      </p>

      <p style="padding: 0 15px" >
        As you can see, this book is very varied in its content. Thus, I though it would make a perfect subject to generate my visualization which I am calling a WikiTree. This WikiTree is a visualtion that is meant to be exploratory. It is meant to allow the viewer to gain a better grasp of the overall context of the book. Keep in mind, it is not meant to summarize the contents of the book. It gives the viewer the ability to view topics related to the book in a hierarchichal fashion.
      </p>

      <p style="padding: 0 15px" >
        This WikiTree was generated using content from Wikipedia articles. The entire structure was generated by finding Wikipidia articles linked within other Wikipedia articles. If a Wikipedia article was found within another Wikipedia article, the former would become a child node of the latter. The linked articles were also pruned based on their relevancy. Relevancy of a linked article was determined based on two criteria: Link Title/Text Relevancy, Percentage of relevant linked articles within the linked article. For the first criteria, the relevancy of the Title and the Text to the book was based on a combo of tf-idf and relative frequency comparisons of the term between hand selected relevant and irrelevant texts. For the second criteria, the criteria would only be met if the percentage of relevant linked articles was greater than a threshold percentage that increased by the level of the tree. The idea behind this was that an article with a high percentage of relevant links would be relevant as a whole and would also lead to many more relevant links. The reasoning behind increasing the threshold percentage with level was that as you went further down levels of the tree, you would only approach more and more irrelevant links, so you would need a stricter criteria to prune articles. This increase was exponential relative to level. Overall, the importance of an article was mostly determined by how well it could lead to more relevant articles, and was pruned according to this heuristic.
      </p>

      <p style="padding: 0 15px" >
        As of now, I have cut the tree off at a maximum height of 4. This was done because of the large computational load to go through any further levels. Perhaps, with a stricter pruning criteria, this maximum height could be increased or (hopefully) eradicated completely so the tree could terminate naturally once it's articles become too irrelevant to the book.
      </p>

      <p style="padding: 0 15px" >
        I chose this specific visualization for two reasons. First, it is clear to see that it is meant for hierarchichal data, which is precisly what I was trying to express. Second, the visualization is interactive in a way that encourages exporation. The viewer can click on any node that they find interesting to expand on that topic and keep going down the tree searching for interesting topics that are all relevant in some way to the book. It also cleanly arranges itself once more than one node is open so that there is no overlap. Overall, the visualization does a good job of expressing the data in a way that I wanted. 
      </p>


    </div>
</div>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var margin = {top: 20, right: 120, bottom: 20, left: 220},
    width = 1060 - margin.right - margin.left,
    height = 800 - margin.top - margin.bottom;
    
var i = 0,
    duration = 750,
    root;

var tree = d3.layout.tree()
    .size([height, width]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.json("wikitree.json", function(error, flare) {
  root = flare;
  root.x0 = height / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  root.children.forEach(collapse);
  update(root);
});

d3.select(self.frameElement).style("height", "800px");

function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
      links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodes…
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", click);

  nodeEnter.append("circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 4.5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}


</script>